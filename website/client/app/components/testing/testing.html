<template name="testing">
  <div id="testing">

    <h2>FDA Title 21: Validation vs Verification Testing</h2>
    <hr>
    <p>
      The U.S. Food and Drug Administration specifies in the <a href="http://www.accessdata.fda.gov/scripts/cdrh/cfdocs/cfcfr/CFRSearch.cfm?fr=820.75">Code of Federal Regulations Title 21, ยง 820.75</a> (hereafter referred to as 21CFR820.75) that medical devices require both <b>verification</b> and <b>validation</b> testing.  These terms comes from the field of process engineering (think Six Sigma), and are known in the software industry as <b>unit testing</b> and <b>acceptance testing</b>.  StarryNight is the culmination of two years of work towards getting Meteor apps FDA certified, and we'll use those terms extensively through this documentation and within the utility itself.  For more information, please see <a href="http://www.fda.gov/downloads/RegulatoryInformation/Guidances/ucm126955.pdf">General Principles of Software Validation; Final Guidance for Industry and FDA Staff</a>
    </p>


    {{> testingQuickstart}}

    <h2>Testing Frameworks</h2>
    <hr>
    <!-- <p>
      Supports package testing via TinyTest framework; and acceptance testing and unit testing via the Nightwatch testing framework.  Here's the quick-and-simple way of getting started.
    </p> -->
    <p>
      <b>nightwatch</b><br>
      Node based library for managing Selenium servers.  Supports acceptance testing, unit testing, screenshots, tagging, and many more advanced features.
    </p>
    <!-- <p>
      <b>tinytest</b><br>
      Meteor's built in test framework for testing isopacks. Tests on both client and server.  Runs in a web-browser with user interface.
    </p> -->
    <p>
      <b>tinytest-ci</b><br>
      Meteor's built in test framework for testing isopacks. Tests on both client and server.  Runs in a web-browser with user interface.
    </p>
    <p>
      <b>multi</b><br>
      An experimental multi-framework option that runs both Nightwatch and TinyTest-CI.
    </p>
    <span class="gray">
      <p>
        <b>end-to-end</b><br>
        Experimental framework based on mocha which supports testing OAuth functionality.  <a href="https://github.com/meteor/e2e">Originally written by the MDG</a>, you might want to take a look at the <a href="https://github.com/awatson1978/e2e/tree/community-use">community use fork</a> for experimenting in your own apps.
      </p>
    </span>
      {{#prism language="bash" class="line-numbers"}}
        # run all the tests/nightwatch files using the default chrome environment
        starrynight run-tests --framework nightwatch --autogenerated

        # silently run tests gathered from throughout the app
        starrynight run-tests --framework nightwatch --env phantomjs --autogenerated

        # run unittests with the application not running
        starrynight run-tests --framework nightwatch --env unittests --autogenerated

        # run package unit tests
        starrynight run-tests --framework tinytest-ci
      {{/prism}}

    <!-- <span class="gray">
      <p>
        <b>spacejam</b><br>
        Package testing framework that extends TinyTest with chai assertions and a command line option.  A little inconsistent with launching, so it's remaining in experimental status for the time being.
      </p>
      <p>
        <b>mocha</b><br>
        Unit/Integration testing framework for Node.  Framework launches, but cannot find config file and/or test files, so remaining in experimental status.
      </p>
      <p>
        <b>pioneer</b><br>
        Acceptance testing framework that uses Cucumber, which itself uses Selenium with Gherkin syntax, a behavior-driven-development style.  Framework launches, but cannot find config file and/or test files, so remaining in experimental status.
      </p>
      <p>
        <b>jasmine</b><br>
        Unit/Integration testing framework for Node.  Experimental support.  Framework launches, but cannot find config file and/or test files, so remaining in experimental status.
      </p>
    </span> -->





    <h2>Testing Modes</h2>
    <hr>
      <p>
        StarryNight combines functionality from a number of testing libraries, some of which overlap.  Rather than specifying a particular test framework to use; it's often benefitial to specify which part of the architecture you want to test.  Which is what Test Modes provide.  A way to specify which part of the architecture your reviewing for FDA compliance.  Note:  these testing modes are not entirely implemented yet, and will eventually be supported by the <b>run-tests</b> command.
      </p>
      <p>
        <b>all</b><br>
        Alias for running both validation and verification tests.
      </p>
      <p>
        <b>validation</b><br>
        Also known as black-box or acceptance testing.  Alias for running both client-validation and package-validation tests.
      </p>
      <p>
        <b>verification</b><br>
        Also known as unit-testing or integration testing.  Runs client, package, and server unit tests using TinyTest, Mocha, and Nightwatch.
      </p>
      <p>
        <b>package-verification</b><br>
        Unit testing of Meteor packages using TinyTest.
      </p>
      <p>
        <b>package-validation</b><br>
        Acceptance testing of Meteor packages using an automated browser controlled by Selenium.
      </p>
      <p>
        <b>server-verification</b><br>
        Unit testing of Meteor server code using Mocha syntax.
      </p>
      <p>
        <b>client-verification</b><br>
        Unit testing of Meteor client code using Nightwatch and Chai syntax.
      </p>
      <p>
        <b>client-validation</b><br>
        Acceptance testing of Meteor client code using an automated browser controlled by Selenium.
      </p>


    <h2>Adding Nightwatch Tests to Your App</h2>
    <hr>
    <p>
      {{#prism language="bash" class="line-numbers"}}
        # generate your .meteor/nightwatch.json config file
        starrynight generate-autoconfig

        # add /tests/nightwatch files
        starrynight scaffold --framework nightwatch
      {{/prism}}
    </p>

    <h2>App Surface Coverage</h2>
    <hr>
    <p>
      lorem ipsum...
      {{#prism language="javascript" class="line-numbers"}}
          module.exports = {
            "Layout & Static Pages" : function (client) {
              client
                .url("http://localhost:3000")
                .resizeWindow(1024, 768)
                .reviewMainLayout()
                .end();
            }
          };
      {{/prism}}
    </p>
    <h2>Component Surface Coverage</h2>
    <hr>
    <p>
      lorem ipsum...
    </p>
    <h2>Testing Component Output</h2>
    <hr>
    <p>
      lorem ipsum...
    </p>
    <h2>Testing Component User Input</h2>
    <hr>
    <p>
      lorem ipsum...
    </p>
    <h2>System Specification Documents</h2>
    <hr>
    <p>
      lorem ipsum...
    </p>

    <h2>Configuration Autogeneration</h2>
    <hr>
    <p>
      Lets scan the filesystem.
    </p>
    {{#prism language="bash" class="line-numbers"}}
      # generate your autoconfig
      starrynight generate-autoconfig

      # then use it
      starrynight run-tests --nightwatch --autogenerated
    {{/prism}}

    <h2>Client Verification Testing</h2>
    <hr>
    <p>
      More commonly known as unit-testing, Verification Testing doesn't test the Document Object Model (DOM) that the user interacts with.  Rather, it inspects the underlying javascript functions on the client.  Client-side verification testing can also test Meteor methods on the server.  Consider an ultra-simple Meteor app that has the following code.
    </p>
    {{#prism language="javascript" class="line-numbers"}}
      if(Meteor.isClient()){
        Session.setDefault("loggedInUser", "Jane Doe")
      }
      if(Meteor.isServer()){
        Meteor.methods({
          testMethod:function(){
             return "abc";
          },
          testMethodWithInput:function(value){
             return value * 2;
          }
        });
      }
    {{/prism}}

    <p>
      Our Nightwatch script to test the above code would look something like the following:
    </p>
    {{#prism language="javascript" class="line-numbers" data-line="7, 15-20"}}
      module.exports = {
        "Check Client Session" : function (client) {

          var sessionBar = false;
          client
            .url("http://localhost:3000/list/users")
            .checkSession("loggedInUser", "Jane Doe")
            .end();
        },
        "Check Server Methods" : function (client) {

          var sessionBar = false;
          client
            .url("http://localhost:3000/list/users")
            .meteorCall("testMethod", false, function(error, result){
              client.assert.equal(result, "abc");
            })
            .meteorCall("testMethodWithInput", 3, function(error, result){
              client.assert.equal(result, 6);
            })
            .end();
        }
      };
    {{/prism}}




    <h2>Isomorphic Validation API</h2>
    <hr>
    <p>
      Support for isomorphic validation testing across client and packages is now available, as of version 0.2.61.  Support includes package refactoring tools, filsystem scanning and autogeneration of nightwatch files, and use of autogenerated config files in the test runner.
    </p>
    {{#prism language="bash"}}
      # create our meteor application
      meteor create helloworld
      cd helloworld
      mkdir client/components/foo/.tests
      nano client/components/foo/foo.html
      nano client/components/foo/foo.js
      nano client/components/foo/foo.css
      nano client/components/foo/.tests/testFoo.js

      # create a package from a component
      $ starrynight create --package myname:foo --from client/components/foo

      # scan filesystem for .tests directories and build our autoconfig
      $ starrynight generate-autoconfig

      # run nightwatch tests from packages
      $ starrynight run-tests --framework nightwatch --autogenerated

      # run nightwatch tests
      $ starrynight run-tests --framework tinytest-ci
    {{/prism}}

    <h2>Testing Rest APIS</h2>
    <hr>
    <p>
      {{#prism language="javascript" class="line-numbers"}}
          module.exports = {
            "Rest API" : function (client) {
              client
                .url("http://localhost:3000/foo")

                .url("http://localhost:3000/bar")

                .url("http://localhost:3000/foo/post")
                .end();
            }
          };
      {{/prism}}
    </p>

    <h2>Testing Meteor Methods</h2>
    <hr>
    <p>
      {{#prism language="javascript" class="line-numbers"}}

      {{/prism}}
    </p>
    <h2>Multi-Window PingPong Testing</h2>
    <hr>
    <p>
      {{#prism language="javascript" class="line-numbers"}}

      {{/prism}}
    </p>



  </div>
</template>
